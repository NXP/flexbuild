From c1bf1546016c2e043ae32cf899ecafd10c791277 Mon Sep 17 00:00:00 2001
From: Lei Xu <lei.xu@nxp.com>
Date: Fri, 20 Jun 2025 14:52:36 +0800
Subject: [PATCH 12/24] LFU-897-1:frdm-imx95: Add FRDM-IMX95 board support

Add board level code and defconfig for FRDM-IMX95 board.

Signed-off-by: Lei Xu <lei.xu@nxp.com>
Signed-off-by: Steven Yang <zhao.yang_1@nxp.com>
Reviewed-by: Ye Li <ye.li@nxp.com>
---
 arch/arm/mach-imx/imx9/Kconfig            |   7 +
 board/freescale/imx95_frdm/Kconfig        |  12 +
 board/freescale/imx95_frdm/MAINTAINERS    |   6 +
 board/freescale/imx95_frdm/Makefile       |  11 +
 board/freescale/imx95_frdm/imx95_frdm.c   | 509 ++++++++++++++++++++++
 board/freescale/imx95_frdm/imx95_frdm.env | 137 ++++++
 board/freescale/imx95_frdm/spl.c          |  95 ++++
 configs/imx95_15x15_frdm_defconfig        | 232 ++++++++++
 include/configs/imx95_frdm.h              |  27 ++
 9 files changed, 1036 insertions(+)
 create mode 100644 board/freescale/imx95_frdm/Kconfig
 create mode 100644 board/freescale/imx95_frdm/MAINTAINERS
 create mode 100644 board/freescale/imx95_frdm/Makefile
 create mode 100644 board/freescale/imx95_frdm/imx95_frdm.c
 create mode 100644 board/freescale/imx95_frdm/imx95_frdm.env
 create mode 100644 board/freescale/imx95_frdm/spl.c
 create mode 100644 configs/imx95_15x15_frdm_defconfig
 create mode 100644 include/configs/imx95_frdm.h

diff --git a/arch/arm/mach-imx/imx9/Kconfig b/arch/arm/mach-imx/imx9/Kconfig
index da8f81cdd7d..2fa56cdc7e1 100644
--- a/arch/arm/mach-imx/imx9/Kconfig
+++ b/arch/arm/mach-imx/imx9/Kconfig
@@ -143,6 +143,12 @@ config TARGET_IMX95_15X15_EVK
 	imply BOOTSTD_BOOTCOMMAND
 	imply BOOTSTD_FULL
 
+config TARGET_IMX95_15X15_FRDM
+	bool "imx95_15x15_frdm"
+	select IMX95
+	imply BOOTSTD_BOOTCOMMAND
+	imply BOOTSTD_FULL
+
 config TARGET_IMX943_EVK
 	bool "imx943_evk"
 	select IMX94
@@ -161,6 +167,7 @@ source "board/freescale/imx93_frdm/Kconfig"
 source "board/phytec/phycore_imx93/Kconfig"
 source "board/variscite/imx93_var_som/Kconfig"
 source "board/freescale/imx95_evk/Kconfig"
+source "board/freescale/imx95_frdm/Kconfig"
 source "board/toradex/verdin-imx95/Kconfig"
 source "board/freescale/imx94_evk/Kconfig"
 
diff --git a/board/freescale/imx95_frdm/Kconfig b/board/freescale/imx95_frdm/Kconfig
new file mode 100644
index 00000000000..0dd10dd46cb
--- /dev/null
+++ b/board/freescale/imx95_frdm/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_IMX95_15X15_FRDM
+
+config SYS_BOARD
+	default "imx95_frdm"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_CONFIG_NAME
+	default "imx95_frdm"
+
+endif
diff --git a/board/freescale/imx95_frdm/MAINTAINERS b/board/freescale/imx95_frdm/MAINTAINERS
new file mode 100644
index 00000000000..22b19ab78c3
--- /dev/null
+++ b/board/freescale/imx95_frdm/MAINTAINERS
@@ -0,0 +1,6 @@
+FRDM-IMX95 BOARD
+M:	Lei Xu <lei.xu@nxp.com>
+S:	Maintained
+F:	board/freescale/imx95_frdm/
+F:	include/configs/imx95_frdm.h
+F:	configs/imx95_15x15_frdm_defconfig
diff --git a/board/freescale/imx95_frdm/Makefile b/board/freescale/imx95_frdm/Makefile
new file mode 100644
index 00000000000..7b1f7657562
--- /dev/null
+++ b/board/freescale/imx95_frdm/Makefile
@@ -0,0 +1,11 @@
+#
+# Copyright 2025 NXP
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y += imx95_frdm.o
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+endif
diff --git a/board/freescale/imx95_frdm/imx95_frdm.c b/board/freescale/imx95_frdm/imx95_frdm.c
new file mode 100644
index 00000000000..3e3e589a566
--- /dev/null
+++ b/board/freescale/imx95_frdm/imx95_frdm.c
@@ -0,0 +1,509 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2025 NXP
+ */
+
+#include <env.h>
+#include <init.h>
+#include <fdt_support.h>
+#include <asm/arch/clock.h>
+#include <usb.h>
+#include "../common/tcpc.h"
+#include <dwc3-uboot.h>
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <asm/gpio.h>
+#include <power/regulator.h>
+#include <scmi_agent.h>
+#include "../dts/upstream/src/arm64/freescale/imx95-power.h"
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <adc.h>
+#include <dm/uclass.h>
+#include <dm/uclass-internal.h>
+
+extern int board_fix_fdt_fuse(void *fdt);
+
+int board_early_init_f(void)
+{
+	/* UART1: A55, UART2: M33, UART3: M7 */
+	init_uart_clk(0);
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_TCPC
+struct tcpc_port port;
+struct tcpc_port portpd;
+struct tcpc_port_config port_config = {
+	.i2c_bus = 2, /* i2c3 */
+	.addr = 0x50,
+	.port_type = TYPEC_PORT_DRP,
+	.disable_pd = true,
+};
+
+struct tcpc_port_config portpd_config = {
+	.i2c_bus = 2, /*i2c3*/
+	.addr = 0x52,
+	.port_type = TYPEC_PORT_UFP,
+	.max_snk_mv = 20000,
+	.max_snk_ma = 3000,
+	.max_snk_mw = 15000,
+	.op_snk_mv = 9000,
+};
+
+ulong tca_base;
+
+void tca_mux_select(enum typec_cc_polarity pol)
+{
+	u32 val;
+
+	if (!tca_base)
+		return;
+
+	/* reset XBar block */
+	setbits_le32(tca_base, BIT(9));
+
+	/* Set OP mode to System configure Mode */
+	clrbits_le32(tca_base + 0x10, 0x3);
+
+	val = readl(tca_base + 0x30);
+
+	WARN_ON((val & GENMASK(1, 0)) != 0x3);
+	WARN_ON((val & BIT(2)) != 0);
+	WARN_ON((val & BIT(3)) != 0);
+	WARN_ON((val & BIT(4)) != 0);
+
+	printf("tca pstate 0x%x\n", val);
+
+	setbits_le32(tca_base + 0x18, BIT(3));
+	udelay(1);
+
+	if (pol == TYPEC_POLARITY_CC1)
+		clrbits_le32(tca_base + 0x18, BIT(2));
+	else
+		setbits_le32(tca_base + 0x18, BIT(2));
+
+	udelay(1);
+
+	clrbits_le32(tca_base + 0x18, BIT(3));
+}
+
+static void setup_typec(void)
+{
+	int ret;
+
+	tca_base = USB1_BASE_ADDR + 0xfc000;
+
+	struct gpio_desc ext_pwr_desc;
+
+	ret = tcpc_init(&portpd, portpd_config, NULL);
+	if (ret) {
+		printf("%s: tcpc portpd init failed, err=%d\n",
+		       __func__, ret);
+	} else if (tcpc_pd_sink_check_charging(&portpd)) {
+		printf("Power supply on USB PD\n");
+
+		/* Enable EXT PWR */
+		ret = dm_gpio_lookup_name("GPIO5_9", &ext_pwr_desc);
+		if (ret) {
+			printf("%s lookup GPIO5_9 failed ret = %d\n", __func__, ret);
+			return;
+		}
+
+		ret = dm_gpio_request(&ext_pwr_desc, "ext_pwr_en");
+		if (ret) {
+			printf("%s request ext_pwr_en failed ret = %d\n", __func__, ret);
+			return;
+		}
+
+		/* Enable EXT PWR */
+		dm_gpio_set_dir_flags(&ext_pwr_desc, GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	}
+
+	ret = tcpc_init(&port, port_config, &tca_mux_select);
+	if (ret) {
+		printf("%s: tcpc init failed, err=%d\n", __func__, ret);
+		return;
+	}
+}
+#endif
+
+#ifdef CONFIG_USB_DWC3
+
+#define PHY_CTRL0			0xF0040
+#define PHY_CTRL0_REF_SSP_EN		BIT(2)
+#define PHY_CTRL0_FSEL_MASK		GENMASK(10, 5)
+#define PHY_CTRL0_FSEL_24M		0x2a
+#define PHY_CTRL0_FSEL_100M		0x27
+#define PHY_CTRL0_SSC_RANGE_MASK	GENMASK(23, 21)
+#define PHY_CTRL0_SSC_RANGE_4003PPM	(0x2 << 21)
+
+#define PHY_CTRL1			0xF0044
+#define PHY_CTRL1_RESET			BIT(0)
+#define PHY_CTRL1_COMMONONN		BIT(1)
+#define PHY_CTRL1_ATERESET		BIT(3)
+#define PHY_CTRL1_DCDENB		BIT(17)
+#define PHY_CTRL1_CHRGSEL		BIT(18)
+#define PHY_CTRL1_VDATSRCENB0		BIT(19)
+#define PHY_CTRL1_VDATDETENB0		BIT(20)
+
+#define PHY_CTRL2			0xF0048
+#define PHY_CTRL2_TXENABLEN0		BIT(8)
+#define PHY_CTRL2_OTG_DISABLE		BIT(9)
+
+#define PHY_CTRL6			0xF0058
+#define PHY_CTRL6_RXTERM_OVERRIDE_SEL	BIT(29)
+#define PHY_CTRL6_ALT_CLK_EN		BIT(1)
+#define PHY_CTRL6_ALT_CLK_SEL		BIT(0)
+
+static struct dwc3_device dwc3_device_data = {
+#ifdef CONFIG_XPL_BUILD
+	.maximum_speed = USB_SPEED_HIGH,
+#else
+	.maximum_speed = USB_SPEED_SUPER,
+#endif
+	.base = USB1_BASE_ADDR,
+	.dr_mode = USB_DR_MODE_PERIPHERAL,
+	.index = 0,
+	.power_down_scale = 2,
+};
+
+static void dwc3_nxp_usb_phy_init(struct dwc3_device *dwc3)
+{
+	u32 value;
+
+	/* USB3.0 PHY signal fsel for 24M ref */
+	value = readl(dwc3->base + PHY_CTRL0);
+	value &= ~PHY_CTRL0_FSEL_MASK;
+	value |= FIELD_PREP(PHY_CTRL0_FSEL_MASK, PHY_CTRL0_FSEL_24M);
+	writel(value, dwc3->base + PHY_CTRL0);
+
+	/* Disable alt_clk_en and use internal MPLL clocks */
+	value = readl(dwc3->base + PHY_CTRL6);
+	value &= ~(PHY_CTRL6_ALT_CLK_SEL | PHY_CTRL6_ALT_CLK_EN);
+	writel(value, dwc3->base + PHY_CTRL6);
+
+	value = readl(dwc3->base + PHY_CTRL1);
+	value &= ~(PHY_CTRL1_VDATSRCENB0 | PHY_CTRL1_VDATDETENB0);
+	value |= PHY_CTRL1_RESET | PHY_CTRL1_ATERESET;
+	writel(value, dwc3->base + PHY_CTRL1);
+
+	value = readl(dwc3->base + PHY_CTRL0);
+	value |= PHY_CTRL0_REF_SSP_EN;
+	writel(value, dwc3->base + PHY_CTRL0);
+
+	value = readl(dwc3->base + PHY_CTRL2);
+	value |= PHY_CTRL2_TXENABLEN0 | PHY_CTRL2_OTG_DISABLE;
+	writel(value, dwc3->base + PHY_CTRL2);
+
+	udelay(10);
+
+	value = readl(dwc3->base + PHY_CTRL1);
+	value &= ~(PHY_CTRL1_RESET | PHY_CTRL1_ATERESET);
+	writel(value, dwc3->base + PHY_CTRL1);
+}
+#endif
+
+static int imx9_scmi_power_domain_enable(u32 domain, bool enable)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device_by_name(UCLASS_CLK, "protocol@14", &dev);
+	if (ret)
+		return ret;
+
+	return scmi_pwd_state_set(dev, 0, domain, enable ? 0 : BIT(30));
+}
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	int ret = 0;
+
+	if (index == 0 && init == USB_INIT_DEVICE) {
+		ret = imx9_scmi_power_domain_enable(IMX95_PD_HSIO_TOP, true);
+		if (ret) {
+			printf("SCMI_POWWER_STATE_SET Failed for USB\n");
+			return ret;
+		}
+
+#ifdef CONFIG_USB_DWC3
+		dwc3_nxp_usb_phy_init(&dwc3_device_data);
+#endif
+#ifdef CONFIG_USB_TCPC
+		ret = tcpc_setup_ufp_mode(&port);
+		if (ret)
+			return ret;
+#endif
+#ifdef CONFIG_USB_DWC3
+		return dwc3_uboot_init(&dwc3_device_data);
+#endif
+	} else if (index == 0 && init == USB_INIT_HOST) {
+#ifdef CONFIG_USB_TCPC
+		ret = tcpc_setup_dfp_mode(&port);
+#endif
+		return ret;
+	}
+
+	return 0;
+}
+
+int board_usb_cleanup(int index, enum usb_init_type init)
+{
+	int ret = 0;
+
+	if (index == 0 && init == USB_INIT_DEVICE) {
+#ifdef CONFIG_USB_DWC3
+		dwc3_uboot_exit(index);
+#endif
+	} else if (index == 0 && init == USB_INIT_HOST) {
+#ifdef CONFIG_USB_TCPC
+		ret = tcpc_disable_src_vbus(&port);
+#endif
+	}
+
+	return ret;
+}
+
+static void netc_phy_rst(const char *gpio_name, const char *label)
+{
+	int ret;
+	struct gpio_desc desc;
+
+	/* ENET_RST_B */
+	ret = dm_gpio_lookup_name(gpio_name, &desc);
+	if (ret) {
+		printf("%s lookup %s failed ret = %d\n", __func__, gpio_name, ret);
+		return;
+	}
+
+	ret = dm_gpio_request(&desc, label);
+	if (ret) {
+		printf("%s request %s failed ret = %d\n", __func__, label, ret);
+		return;
+	}
+
+	/* assert the ENET_RST_B */
+	dm_gpio_set_dir_flags(&desc, GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE | GPIOD_ACTIVE_LOW);
+	udelay(10000);
+	dm_gpio_set_value(&desc, 0); /* deassert the ENET_RST_B */
+	udelay(80000);
+}
+
+void netc_init(void)
+{
+	int ret;
+
+	ret = imx9_scmi_power_domain_enable(IMX95_PD_NETC, false);
+	udelay(10000);
+
+	/* Power up the NETC MIX. */
+	ret = imx9_scmi_power_domain_enable(IMX95_PD_NETC, true);
+	if (ret) {
+		printf("SCMI_POWWER_STATE_SET Failed for NETC MIX\n");
+		return;
+	}
+
+	netc_phy_rst("gpio@22_0", "ENET1_RST_B");
+	netc_phy_rst("gpio@22_1", "ENET2_RST_B");
+
+	pci_init();
+}
+
+void lvds_backlight_on(void)
+{
+	struct udevice *dev;
+	int ret;
+	u8 reg;
+
+	ret = i2c_get_chip_for_busnum(2, 0x62, 1, &dev);
+	if (ret) {
+		printf("%s: Cannot find pca9632 led dev\n",
+		       __func__);
+		return;
+	}
+
+	reg = 1;
+	dm_i2c_write(dev, 0x1, &reg, 1);
+
+	reg = 5;
+	dm_i2c_write(dev, 0x8, &reg, 1);
+}
+
+static int print_board_version(void)
+{
+	int i, ret;
+	struct udevice *dev;
+	unsigned int rev[2];
+	unsigned int data[2];
+
+	ret = uclass_first_device_check(UCLASS_ADC, &dev);
+
+	if (dev) {
+		ret = adc_channel_single_shot(dev->name, 2, &data[0]);
+		if (ret) {
+			printf("BOARD: unknown\n");
+			return 0;
+		}
+		ret = adc_channel_single_shot(dev->name, 3, &data[1]);
+		if (ret) {
+			printf("BOARD: unknown\n");
+			return 0;
+		}
+
+		for (i = 0; i < 2; i++) {
+			if (data[i] < 500)
+				rev[i] = 0;
+			else if (data[i] < 700)
+				rev[i] = 1;
+			else if (data[i] < 1500)
+				rev[i] = 2;
+			else if (data[i] < 2300)
+				rev[i] = 3;
+			else if (data[i] < 3000)
+				rev[i] = 4;
+			else if (data[i] < 3600)
+				rev[i] = 5;
+			else
+				rev[i] = 6;
+		}
+		printf("BOARD: V%d.%d(ADC2:%d,ADC3:%d)\n", rev[0], rev[1], data[0], data[1]);
+	} else {
+		printf("BOARD: unknown\n");
+	}
+
+	return 0;
+}
+
+int board_init(void)
+{
+	int ret;
+
+	print_board_version();
+
+	ret = imx9_scmi_power_domain_enable(IMX95_PD_HSIO_TOP, true);
+	if (ret) {
+		printf("SCMI_POWWER_STATE_SET Failed for USB\n");
+		return ret;
+	}
+
+	imx9_scmi_power_domain_enable(IMX95_PD_DISPLAY, false);
+	imx9_scmi_power_domain_enable(IMX95_PD_CAMERA, false);
+
+#if defined(CONFIG_USB_TCPC)
+	setup_typec();
+#endif
+
+	netc_init();
+
+	power_on_m7("mx95evkrpmsg");
+
+	lvds_backlight_on();
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	if (IS_ENABLED(CONFIG_ENV_IS_IN_MMC))
+		board_late_mmc_env_init();
+
+	env_set("sec_boot", "no");
+#ifdef CONFIG_AHAB_BOOT
+	env_set("sec_boot", "yes");
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	char *p, *b, *s;
+	char *token = NULL;
+	int i, ret = 0;
+	u64 base[CONFIG_NR_DRAM_BANKS] = {0};
+	u64 size[CONFIG_NR_DRAM_BANKS] = {0};
+
+	p = env_get("jh_root_mem");
+	if (!p)
+		return 0;
+
+	i = 0;
+	token = strtok(p, ",");
+	while (token) {
+		if (i >= CONFIG_NR_DRAM_BANKS) {
+			printf("Error: The number of size@base exceeds CONFIG_NR_DRAM_BANKS.\n");
+			return -EINVAL;
+		}
+
+		b = token;
+		s = strsep(&b, "@");
+		if (!s) {
+			printf("The format of jh_root_mem is size@base[,size@base...].\n");
+			return -EINVAL;
+		}
+		base[i] = simple_strtoull(b, NULL, 16);
+		size[i] = simple_strtoull(s, NULL, 16);
+		token = strtok(NULL, ",");
+		i++;
+	}
+
+	ret = fdt_fixup_memory_banks(blob, base, size, CONFIG_NR_DRAM_BANKS);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+#endif
+
+int board_phys_sdram_size(phys_size_t *size)
+{
+	*size = PHYS_SDRAM_SIZE + PHYS_SDRAM_2_SIZE;
+
+	return 0;
+}
+
+void board_quiesce_devices(void)
+{
+	int ret;
+	struct uclass *uc_dev;
+
+	ret = imx9_scmi_power_domain_enable(IMX95_PD_HSIO_TOP, false);
+	if (ret) {
+		printf("%s: Failed for HSIO MIX: %d\n", __func__, ret);
+		return;
+	}
+
+	ret = imx9_scmi_power_domain_enable(IMX95_PD_NETC, false);
+	if (ret) {
+		printf("%s: Failed for NETC MIX: %d\n", __func__, ret);
+		return;
+	}
+
+	ret = uclass_get(UCLASS_SPI_FLASH, &uc_dev);
+	if (uc_dev)
+		ret = uclass_destroy(uc_dev);
+	if (ret)
+		printf("couldn't remove SPI FLASH devices\n");
+}
+
+#if IS_ENABLED(CONFIG_OF_BOARD_FIXUP)
+
+int board_fix_fdt(void *fdt)
+{
+	/* Remove nodes based on fuses. */
+	board_fix_fdt_fuse(fdt);
+	return 0;
+}
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+#ifdef CONFIG_ANDROID_RECOVERY
+int is_recovery_key_pressing(void)
+{
+	return 0;
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+#endif /*CONFIG_FSL_FASTBOOT*/
diff --git a/board/freescale/imx95_frdm/imx95_frdm.env b/board/freescale/imx95_frdm/imx95_frdm.env
new file mode 100644
index 00000000000..9c4389c0472
--- /dev/null
+++ b/board/freescale/imx95_frdm/imx95_frdm.env
@@ -0,0 +1,137 @@
+#include <env/nxp/imx_env.env>
+
+#ifdef CONFIG_ANDROID_SUPPORT
+splashpos=m,m
+splashimage=0x9FFF0000
+fdt_high=0xffffffffffffffff
+initrd_high=0xffffffffffffffff
+emmc_dev=0
+sd_dev=1
+#else
+
+#ifdef CONFIG_AHAB_BOOT
+sec_boot=yes
+#else
+sec_boot=no
+#endif
+
+jh_root_dtb=imx95-15x15-frdm-root.dtb
+jh_mmcboot=setenv fdtfile ${jh_root_dtb};
+	setenv jh_clk kvm.enable_virt_at_load=false cpuidle.off=1 clk_ignore_unused kvm-arm.mode=nvhe;
+	setenv jh_root_mem 0x58000000@0x90000000,0xc0000000@0x180000000;
+	if run loadimage; then
+		run mmcboot;
+	else run jh_netboot; fi;
+jh_netboot=setenv fdtfile ${jh_root_dtb};
+	setenv jh_root_mem 0x58000000@0x90000000,0xc0000000@0x180000000;
+	setenv jh_clk kvm.enable_virt_at_load=false cpuidle.off=1 clk_ignore_unused kvm-arm.mode=nvhe; run netboot;
+
+domu-android-auto=no
+xenhyper_bootargs=console=dtuart dom0_mem=4096M dom0_max_vcpus=2 pci-passthrough=on
+xenlinux_bootargs=
+xenlinux_console=hvc0 earlycon=xen
+xenlinux_addr=0x9c000000
+dom0fdt_file=CONFIG_DEFAULT_FDT_FILE
+xenboot_common=${get_cmd} ${loadaddr} xen;
+	${get_cmd} ${fdt_addr} ${dom0fdt_file};
+	${get_cmd} ${xenlinux_addr} ${image};
+	fdt addr ${fdt_addr};
+	fdt resize 256;
+	fdt mknode /chosen module@0;
+	fdt set /chosen/module@0 reg <0x00000000 ${xenlinux_addr} 0x00000000 0x${filesize}>;
+	fdt set /chosen/module@0 bootargs "${bootargs} ${xenlinux_bootargs}";
+	fdt set /soc/bus@49000000/iommu@490d0000 status disabled;
+	fdt set /chosen/module@0 compatible "xen,linux-zimage" "xen,multiboot-module";
+	setenv bootargs ${xenhyper_bootargs};
+	booti ${loadaddr} - ${fdt_addr};
+xennetboot=setenv get_cmd dhcp;setenv console ${xenlinux_console};setenv jh_clk kvm.enable_virt_at_load=false clk_ignore_unused;run netargs;run xenboot_common;
+xenmmcboot=setenv get_cmd "fatload mmc ${mmcdev}:${mmcpart}";setenv console ${xenlinux_console};setenv jh_clk kvm.enable_virt_at_load=false clk_ignore_unused;run mmcargs;run xenboot_common;
+
+initrd_addr=0x93800000
+initrd_high=0xffffffffffffffff
+emmc_dev=0
+sd_dev=1
+scriptaddr=0x93500000
+kernel_addr_r=CONFIG_SYS_LOAD_ADDR
+image=Image
+splashimage=0xA0000000
+console=ttyLP0,115200 earlycon
+fdt_addr_r=0x93000000
+fdt_addr=0x93000000
+cntr_addr=0xA8000000
+cntr_file=os_cntr_signed.bin
+boot_fit=no
+fdtfile=CONFIG_DEFAULT_FDT_FILE
+bootm_size=0x10000000
+mmcdev=CONFIG_SYS_MMC_ENV_DEV
+mmcpart=1
+mmcroot=/dev/mmcblk1p2 rootwait rw
+mmcautodetect=yes
+mmcargs=setenv bootargs ${jh_clk} ${mcore_args} console=${console} root=${mmcroot}
+prepare_mcore=setenv mcore_args pd_ignore_unused;
+loadbootscript=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};
+bootscript=echo Running bootscript from mmc ...; source
+loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}
+loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr_r} ${fdtfile}
+loadcntr=fatload mmc ${mmcdev}:${mmcpart} ${cntr_addr} ${cntr_file}
+auth_os=booti ${cntr_addr}
+boot_os=booti ${loadaddr} - ${fdt_addr_r};
+mmcboot=echo Booting from mmc ...;
+		run mmcargs;
+		if test ${sec_boot} = yes; then
+			run auth_os;
+		else
+			if test ${boot_fit} = yes || test ${boot_fit} = try; then
+				bootm ${loadaddr};
+			else
+				if run loadfdt; then
+					run boot_os;
+				else
+					echo WARN: Cannot load the DT;
+				fi;
+			fi;
+		fi;
+netargs=setenv bootargs ${jh_clk} ${mcore_args} console=${console} root=/dev/nfs
+		ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp
+netboot=echo Booting from net ...;
+		run netargs;
+		if test ${ip_dyn} = yes; then
+			setenv get_cmd dhcp;
+		else
+			setenv get_cmd tftp;
+		fi;
+		if test ${sec_boot} = yes; then
+			${get_cmd} ${cntr_addr} ${cntr_file};
+			run auth_os;
+		else
+			${get_cmd} ${loadaddr} ${image};
+			if test ${boot_fit} = yes || test ${boot_fit} = try; then
+				bootm ${loadaddr};
+			else
+				if ${get_cmd} ${fdt_addr_r} ${fdtfile}; then
+					run boot_os;
+				else
+					echo WARN: Cannot load the DT;
+				fi;
+			fi;
+		fi;
+bsp_bootcmd=echo Running BSP bootcmd ...;
+			mmc dev ${mmcdev}; if mmc rescan; then
+			if run loadbootscript; then
+				run bootscript;
+			else
+				if test ${sec_boot} = yes; then
+					if run loadcntr; then
+						run mmcboot;
+					else run netboot;
+					fi;
+				else
+					if run loadimage; then
+						run mmcboot;
+					else run netboot;
+					fi;
+				fi;
+			fi;
+		fi;
+
+#endif
diff --git a/board/freescale/imx95_frdm/spl.c b/board/freescale/imx95_frdm/spl.c
new file mode 100644
index 00000000000..c8e7182a564
--- /dev/null
+++ b/board/freescale/imx95_frdm/spl.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2025 NXP
+ */
+
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mu.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/sections.h>
+#include <hang.h>
+#include <init.h>
+#include <spl.h>
+#include <asm/mach-imx/ele_api.h>
+#include <asm/gpio.h>
+#include <linux/delay.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int spl_board_boot_device(enum boot_device boot_dev_spl)
+{
+	switch (boot_dev_spl) {
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		return BOOT_DEVICE_MMC1;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		return BOOT_DEVICE_MMC2;
+	case USB_BOOT:
+		return BOOT_DEVICE_BOARD;
+	case QSPI_BOOT:
+		return BOOT_DEVICE_SPI;
+	default:
+		return BOOT_DEVICE_NONE;
+	}
+}
+
+void spl_board_init(void)
+{
+	int ret;
+
+	puts("Normal Boot\n");
+
+	ret = ele_start_rng();
+	if (ret)
+		printf("Fail to start RNG: %d\n", ret);
+}
+
+void board_init_f(ulong dummy)
+{
+	int ret;
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+#ifdef CONFIG_SPL_RECOVER_DATA_SECTION
+	if (IS_ENABLED(CONFIG_SPL_BUILD))
+		spl_save_restore_data();
+#endif
+
+	timer_init();
+
+	/* Need dm_init() to run before any SCMI calls can be made. */
+	spl_early_init();
+
+	/* Need enable SCMI drivers and ELE driver before enabling console */
+	ret = imx9_probe_mu();
+	if (ret)
+		hang(); /* if MU not probed, nothing can output, just hang here */
+
+	arch_cpu_init();
+
+	board_early_init_f();
+
+	preloader_console_init();
+
+	debug("SOC: 0x%x\n", gd->arch.soc_rev);
+	debug("LC: 0x%x\n", gd->arch.lifecycle);
+
+	get_reset_reason(true, false);
+
+	disable_smmuv3();
+
+	/* Will set ARM freq to max rate */
+	clock_init_late();
+
+	board_init_r(NULL, 0);
+}
+
+#ifdef CONFIG_ANDROID_SUPPORT
+int board_get_emmc_id(void)
+{
+	return 0;
+}
+#endif
diff --git a/configs/imx95_15x15_frdm_defconfig b/configs/imx95_15x15_frdm_defconfig
new file mode 100644
index 00000000000..ce8cbde68e8
--- /dev/null
+++ b/configs/imx95_15x15_frdm_defconfig
@@ -0,0 +1,232 @@
+CONFIG_ARM=y
+CONFIG_ARCH_IMX9=y
+CONFIG_TEXT_BASE=0x90200000
+CONFIG_SYS_MALLOC_LEN=0x2000000
+CONFIG_SYS_MALLOC_F_LEN=0x10000
+CONFIG_SPL_GPIO=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_NR_DRAM_BANKS=3
+CONFIG_ENV_SOURCE_FILE="imx95_frdm"
+CONFIG_SF_DEFAULT_SPEED=40000000
+CONFIG_ENV_SIZE=0x4000
+CONFIG_ENV_OFFSET=0x700000
+CONFIG_ENV_SECT_SIZE=0x10000
+CONFIG_IMX_CONFIG="arch/arm/mach-imx/imx9/scmi/imximage.cfg"
+CONFIG_DM_GPIO=y
+CONFIG_DEFAULT_DEVICE_TREE="imx95-15x15-frdm"
+CONFIG_USB_TCPC=y
+CONFIG_TARGET_IMX95_15X15_FRDM=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_SYS_MONITOR_LEN=524288
+CONFIG_SPL_MMC=y
+CONFIG_SPL_SERIAL=y
+CONFIG_SPL_DRIVERS_MISC=y
+CONFIG_SPL_STACK=0x204d6000
+CONFIG_SPL_TEXT_BASE=0x20480000
+CONFIG_SPL_HAS_BSS_LINKER_SECTION=y
+CONFIG_SPL_BSS_START_ADDR=0x204d6000
+CONFIG_SPL_BSS_MAX_SIZE=0x2000
+CONFIG_SYS_LOAD_ADDR=0x90400000
+CONFIG_SPL=y
+CONFIG_SPL_RECOVER_DATA_SECTION=y
+CONFIG_PCI=y
+CONFIG_SYS_MEMTEST_START=0x90000000
+CONFIG_SYS_MEMTEST_END=0xA0000000
+CONFIG_REMAKE_ELF=y
+CONFIG_FIT=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_BOOTCOMMAND="bootflow scan -l; run bsp_bootcmd"
+CONFIG_DEFAULT_FDT_FILE="imx95-15x15-frdm.dtb"
+CONFIG_SYS_CBSIZE=2048
+CONFIG_SYS_PBSIZE=2074
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_SPL_MAX_SIZE=0x30000
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_LOAD_IMX_CONTAINER=y
+CONFIG_IMX_CONTAINER_CFG="arch/arm/mach-imx/imx9/scmi/container.cfg"
+# CONFIG_SPL_SHARES_INIT_SP_ADDR is not set
+CONFIG_SPL_SYS_MALLOC=y
+CONFIG_SPL_HAS_CUSTOM_MALLOC_START=y
+CONFIG_SPL_CUSTOM_SYS_MALLOC_ADDR=0x93200000
+CONFIG_SPL_SYS_MALLOC_SIZE=0x80000
+CONFIG_SPL_SYS_MMCSD_RAW_MODE=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x1040
+CONFIG_SPL_I2C=y
+CONFIG_SPL_DM_MAILBOX=y
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_POWER=y
+CONFIG_SPL_POWER_DOMAIN=y
+CONFIG_SPL_USB_GADGET=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_SDP_LOADADDR=0x90400000
+
+CONFIG_SPL_WATCHDOG=y
+CONFIG_SYS_PROMPT="u-boot=> "
+CONFIG_CMD_ERASEENV=y
+CONFIG_CMD_NVEDIT_EFI=y
+CONFIG_CMD_CRC32=y
+CONFIG_CRC32_VERIFY=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_POWEROFF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EFIDEBUG=y
+CONFIG_CMD_RTC=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_GETTIME=y
+CONFIG_CMD_TIMER=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_HASH=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_USB_SDP=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_ENV_OVERWRITE=y
+CONFIG_ENV_IS_NOWHERE=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_SYS_MMC_ENV_DEV=1
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_USE_ETHPRIME=y
+CONFIG_ETHPRIME="eth0"
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SYS_RX_ETH_BUFFER=8
+CONFIG_SPL_DM=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_ADC=y
+CONFIG_ADC_IMX93=y
+CONFIG_SPL_OF_TRANSLATE=y
+CONFIG_CLK=y
+CONFIG_SPL_CLK=y
+CONFIG_SPL_CLK_CCF=y
+CONFIG_CLK_CCF=y
+CONFIG_CLK_SCMI=y
+CONFIG_SPL_CLK_SCMI=y
+CONFIG_DFU_MMC=y
+CONFIG_DFU_RAM=y
+CONFIG_SPL_FIRMWARE=y
+# CONFIG_SCMI_AGENT_SMCCC is not set
+CONFIG_IMX_RGPIO2P=y
+
+CONFIG_CMD_FASTBOOT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_UUU_SUPPORT=y
+CONFIG_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x92800000
+CONFIG_FASTBOOT_BUF_SIZE=0x20000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_EFI_PARTITION=y
+CONFIG_FASTBOOT_USB_DEV=0
+CONFIG_USB_PORT_AUTO=y
+
+CONFIG_DM_PCA953X=y
+CONFIG_ADP5585_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_IMX_LPI2C=y
+CONFIG_IMX_MU_MBOX=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_ES_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_FSL_USDHC=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_PHYLIB=y
+CONFIG_PHYLIB_10G=y
+CONFIG_PHY_AQUANTIA=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_MDIO=y
+CONFIG_MII=y
+CONFIG_PHY_MOTORCOMM=y
+CONFIG_FSL_ENETC=y
+CONFIG_PCIE_ECAM_GENERIC=y
+CONFIG_PHY=y
+CONFIG_PHY_IMX8MQ_USB=y
+CONFIG_PINCTRL=y
+CONFIG_SPL_PINCTRL=y
+CONFIG_PINCTRL_IMX_SCMI=y
+CONFIG_POWER_DOMAIN=y
+CONFIG_SCMI_POWER_DOMAIN=y
+CONFIG_DM_REGULATOR=y
+CONFIG_SPL_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_SPL_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_DM_SERIAL=y
+CONFIG_FSL_LPUART=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_NXP_FSPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_MAX_CONTROLLER_COUNT=2
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x1fc9
+CONFIG_USB_GADGET_PRODUCT_NUM=0x0152
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_ULP_WATCHDOG=y
+CONFIG_LZO=y
+CONFIG_BZIP2=y
+CONFIG_OF_BOARD_SETUP=y
+
+CONFIG_IMX_SNPS_DDR_PHY_QB_GEN=y
+CONFIG_SAVED_QB_STATE_BASE=0x4aaf0000
+
+CONFIG_DM_THERMAL=y
+CONFIG_SCMI_THERMAL=y
+CONFIG_SPL_THERMAL=y
+
+CONFIG_VIDEO_IMX95_DPU=y
+CONFIG_VIDEO_IMX95_DW_DSI=y
+CONFIG_VIDEO_IMX95_PIXEL_LINK=y
+CONFIG_VIDEO_IMX95_PIXEL_INTERLEAVER=y
+CONFIG_VIDEO=y
+CONFIG_BMP_16BPP=y
+CONFIG_BMP_24BPP=y
+CONFIG_BMP_32BPP=y
+CONFIG_VIDEO_LOGO=y
+CONFIG_VIDEO_LCD_RAYDIUM_RM692C9=y
+CONFIG_VIDEO_ADV7535=y
+CONFIG_SYS_WHITE_ON_BLACK=y
+CONFIG_SPLASH_SCREEN=y
+CONFIG_SPLASH_SCREEN_ALIGN=y
+CONFIG_CMD_BMP=y
+CONFIG_DISPLAY=y
+CONFIG_MIPI_DPHY_HELPERS=y
+
+CONFIG_BOOTDEV_ETH=n
diff --git a/include/configs/imx95_frdm.h b/include/configs/imx95_frdm.h
new file mode 100644
index 00000000000..bc134aede00
--- /dev/null
+++ b/include/configs/imx95_frdm.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2025 NXP
+ */
+
+#ifndef __IMX95_FRDM_H
+#define __IMX95_FRDM_H
+
+#include <linux/sizes.h>
+#include <linux/stringify.h>
+#include <asm/arch/imx-regs.h>
+
+#define CFG_SYS_INIT_RAM_ADDR		0x90000000
+#define CFG_SYS_INIT_RAM_SIZE		0x200000
+
+#define CFG_SYS_SDRAM_BASE		0x90000000
+#define PHYS_SDRAM			0x90000000
+
+#define PHYS_SDRAM_SIZE			0x70000000 /* 2GB - 256MB DDR */
+#define PHYS_SDRAM_2_SIZE		0x180000000UL /* 6GB */
+
+#define CFG_SYS_SECURE_SDRAM_BASE	0x8A000000
+#define CFG_SYS_SECURE_SDRAM_SIZE	0x06000000
+
+#define WDOG_BASE_ADDR			WDG3_BASE_ADDR
+
+#endif
-- 
2.34.1

